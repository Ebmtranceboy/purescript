Data.Functor              spago install prelude
Control.Applicative
Control.Apply
Control.Monad
Data.Eq
Data.Ordering
Data.Symbol
Prim
Prim.Row
Prim.RowList
(...)

Control.Monad.Aff         spago install aff
Affjax                    spago install affjax
Affjax.Web                spago install affjax-web
Data.Argonaut             spago install argonaut
Data.Array                spago install arrays
FRP.Behavior              spago install behaviors
Data.BigInt               spago install bigints
Graphics.Canvas           spago install canvas
Control.MonadZero         spago install control
Control.Alt
Control.Plus
Debug.Trace               spago install debug
Graphics.Drawing          spago install drawing
Data.Either               spago install either
Data.Enum                 spago install enums
Fetch                     spago install fetch
Data.Compactable          spago install filterable
Data.Traversable          spago install foldable-traversable
Data.Foldable
Data.Foreign              spago install foreign
Data.Function.Uncurried   spago install functions
Data.Int                  spago install integers
Effect.Timer              spago install js-timers
Random.LCG                spago install lcg
Data.List                 spago install lists
Math                      spago install math
Data.Maybe                spago install maybe
Data.Monoid               spago install monoid
Data.Newtype              spago install newtype
Data.Number               spago install numbers
Data.Map                  spago install ordered-collections
Parsing                   spago install parsing
Parsing.Combinators       
Parsing.String
Parsing.String.Basic
Partial.Unsafe            spago install partial
Effect.Random             spago install random
Data.Ratio                spago install rationals
Record                    spago install record
Run                       spago install run
Data.Set                  spago install sets
Control.Monad.ST          spago install st
Data.String               spago install strings
Data.Char
Thermite                  spago install thermite
Control.Monad.State       spago install transformers
Control.Monad.Writer
Data.Tuple                spago install tuples
Type.Prelude              spago install typelevel-prelude
Turbine                   spago install turbine
Unsafe.Reference          spago install unsafe-reference
Data.Validation.Semigroup spago install validation
Web.HTML                  spago install web-html
Audio.WebAudio.Oscillator spago install webaudio

import Affjax.Web (request)
import Control.Alt (alt, (<|>))
import Control.Monad.ST (newSTRef)
import Control.Monad.Writer (Writer, runWriter, tell)
import Control.MonadZero (guard)
import Data.Array (foldM, catMaybes, sort, elem, index, elemIndex)
import Data.Array.Partial (head)
import Data.Char (toCharCode)
import Data.Compactable (compact)
import Data.Either (note, hush)
import Data.Enum (fromEnum)
import Data.Foldable (sum, product, foldM, maximum)
import Data.Function.Uncurried (Fn's, mkFn's, runFn's)
import Data.Int (floor, fromStringAs, toStringAs, binary, octal, hexadecimal, decimal, base36, radix, toNumber)
import Data.List (fromFoldable, filterM, toUnfoldable)
import Data.Maybe (fromJust, maybe)
import Data.Newtype (unwrap)
import Data.Number (fromString, pow)
import Data.Ord (min, max, abs)
import Data.String (toCodePointArray, singleton, fromCodePointArray, codePointFromChar, stripPrefix, Pattern)
import Data.String.CodeUnits (toCharArray, singleton)
import Data.Symbol (class IsSymbol, reflectSymbol)
import Data.Tuple (uncurry)
import Effect.Random (random)
import Effect.Timer (clearInterval, setInteval)
import Fetch (fetch)
import Data.Tuple.Nested ((/\), type (/\))
import Parsing (ParseError, Parser, runParser)
import Parsing.Combinators (try)
import Parsing.String (char)
import Parsing.String.Basic (number, skipSpaces)
import Partial.Unsafe (unsafePartial)
import Prim (Record)
import Prim.Row (class Cons, class Lacks)
import Random.LCG (lcgNext, mkSeed, unSeed)
import Unsafe.Reference (unsafeReferenceEq)

note :: forall a b. a -> Maybe b -> Either a b
hush :: forall a b. Either a b -> Maybe b

applyFlipped :: forall a b. a -> (a -> b) -> b
applyFlipped x f = f x

infixl 1 applyFlipped as #

class Eq a where
  eq :: a -> a -> Boolean
  
data Ordering = LT | EQ | GT

class Eq a <= Ord a where
  compare :: a -> a -> Ordering

class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d

class (Semigroupoid a) <= Category a where
  identity :: forall t. a t t

class Semigroup a where
  append :: a -> a -> a
  
class (Semigroup m) <= Monoid m where
  mempty :: m

class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m

class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

infixl 4 map as <$>

instance covariantArrow :: Covariant (forall a. a -> x) where
  fmap :: (x -> y) -> (a -> x) -> (a -> y) -- result is still a function a -> ...
  fmap = (<<<)

instance contravariantArrow :: Contravariant (forall b. x -> b) where
  cmap :: (x -> b) (b -> y) -> (x -> y) -- result is still a function ... -> b
  cmap = flip (<<<)
  
It appears that a functor (resp. cofunctor) instance can only be defined 
for functions where variables x all are in positive (resp. negative) positions:

p
n -> p
n -> (n -> p)
(p -> n) -> p
n -> (n -> (n -> p))
n -> ((p -> n) -> p)
((n -> p) -> n) -> p 
(p -> (p -> n)) -> p 
(p -> n) -> (n -> p)

for example,
instance covariantArrow2 :: Covariant (forall n. (x -> n) -> x) where
  fmap :: (x -> y) -> ((x -> n) -> x) -> (x -> n) -> y

class (Functor f) <= Apply f where
  apply :: forall a b. f (a -> b) -> f a -> f b 

infixl 4 apply as <*>

applySecond :: forall a b f. Apply f => f a -> f b -> f b

infixl 4 applySecond as *>

class (Apply f) <= Applicative f where
  pure :: forall a. a -> f a

class (Functor t, Foldable t) <= Traversable t where
  traverse :: forall a b f. Applicative f => (a -> f b) -> t a -> f (t b)
  sequence :: forall a f. Applicative f => t (f a) -> f (t a)

-- sequence = traverse identity
-- traverse f = sequence <<< (map f)
-- traverse_ :: forall a b t f. Applicative f => Foldable t => (a -> f b) -> t a -> f Unit

class (Functor f) <= Distributive f where
  distribute :: forall a g. Functor g => g (f a) -> f (g a)
  collect :: forall a b g. Functor g => (a -> f b) -> g a -> f (g b)

cotraverse :: forall a b f g. Distributive f => Functor g => (g a -> b) -> g (f a) -> f b

class (Apply m) <= Bind m where
  bind :: forall a b. m a -> (a -> m b) -> m b

class (Applicative m, Bind m) <= Monad m

class Compactable f where
  compact :: forall a.
    f (Maybe a) -> f a

  separate :: forall l r.
    f (Either l r) -> { left :: f l, right :: f r }

data Tuple a b = Tuple a b

class (Monad m) <= MonadState s m | m -> s where
  state :: forall a. (s -> (Tuple a s)) -> m a

class (Functor env) <= Extend env where -- that is : map f = extend (f <<< duplicate)
  duplicate : forall a. env a -> env (env a) 
  -- that is : duplicate = extend identity
  extend :: forall a b. (env a -> b) -> env a -> env b
  -- that is : extend f = map f <<< duplicate

infixr 1 extend as <<=

composeCoKleisli :: forall b a w c. Extend w => (w a -> b) -> (w b -> c) -> w a -> c
composeCoKleisli f g w = g (f <<= w) -- f =>= extract = f
                                     -- extract =>= f = f
                                     -- f =>= (g =>= h) = (f =>= g) =>= h

infixr 1 composeCoKleisli as =>=

class (Extend env) <= Comonad env where
  extract :: forall a. env a -> a
  
class (Comonad (env e)) <= Environment env e a where
  ask :: env e a -> e
  asks :: forall e'. (e -> e') -> env e a -> e'
  local :: forall e'. (e -> e') -> env e a -> env e' a

class (Functor f) <= Alt f where -- Semigroup for Type -> Type
  alt :: forall a. f a -> f a -> f a

infixl 3 alt as <|> -- Associativity, Distributivity of <$> over <|>

voidRight :: forall f a b. Functor f => a -> f b -> f a
voidRight x = map (const x)

infixl 4 voidRight as <$

class (Alt f) <= Plus f where -- Monoid for Type -> Type
  empty :: forall a. f a

    Left identity: empty <|> x == x
    Right identity: x <|> empty == x
    Annihilation: f <$> empty == empty

class (Applicative f, Plus f) <= Alternative f
class (Monad m, Alternative m) <= MonadZero m 
class (MonadZero m) <= MonadPlus m -- Distributivity: (x <|> y) >>= f == (x >>= f) <|> (y >>= f)

data Free f a = Pure a | Roll (f (Free f a))

instance freeFunctor :: Functor f => Functor (Free f) where
  map f (Pure a) = Pure (f a)
  map f (Roll x) = Roll (map (map f) x)

concatFree :: forall f a. Functor f => Free f (Free f a) -> Free f a
concatFree (Pure x) = x
concatFree (Roll y) = Roll (map concatFree y)

bindFree :: forall a b f. Functor f => Free f a -> (a -> Free f b) -> Free f b
bindFree x f = concatFree (map f x)

instance freeApply :: Functor f => Apply (Free f) where
  apply ff fx =  bindFree fx (\x -> bindFree ff (\f -> Pure $ f x)) 
   
instance freeApplicative :: Functor f => Applicative (Free f) where
  pure = Pure

instance freeBind :: Functor f => Bind (Free f) where
  bind x f = bindFree x f 

liftFree :: forall a f. Functor f => f a -> Free f a
liftFree x = Roll (map Pure x)

foldFree :: forall f r. Functor f => (f r -> r) -> Free f r -> r
foldFree _ (Pure a) = a
foldFree f (Roll x) = f (map (foldFree f) x)

class Bifunctor f where
  bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
  
class (Bifunctor w) <= Biapply w where
  biapply :: w (a -> b) (c -> d) -> w a c -> w b d -- <<*>>
  
class (Biapply w) <= Biapplicative w where
  bipure :: a -> b -> w a b
  
instance biapplyTuple :: Biapply Tuple where
  biapply (Tuple f g) (Tuple a b) = Tuple (f a) (g b)

class Profunctor p where
  dimap :: forall s t a b. (s -> a) -> (b -> t) -> p a b -> p s t
  
class (Profunctor p) <= Strong p where
  first :: forall a b c. p a b -> p (a /\ c) (b /\ c)
  second :: forall a b c. p b c -> p (a /\ b) (a /\ c)

class (Profunctor p) <= Choice p where
  left :: forall a b c. p a b -> p (Either a c) (Either b c)
  right :: forall a b c. p b c -> p (Either a b) (Either a c)

type Optic p s t a b = p a b -> p s t
type Iso s t a b = forall p. Profunctor p => Optic p s t a b
type Lens s t a b = forall p. Strong p => Optic p s t a b
type Prism s t a b = forall p. Choice p => Optic p s t a b

instance Profunctor (->) where
  dimap a c b = a >>> b >>> c
  
instance Strong (->) where
  first f (a /\ c) = f a /\ c
  second = map
  
instance Choice (->) where
  left f (Left a) = Left $ f a
  left _ (Right c) = Right c
  right = map

type Setter s t a b = Optic Function s t a b

over :: forall s t a b. Setter s t a b -> (a -> b) -> s -> t
over = identity

newtype Forget r a b = Forget (a -> r)

instance Profunctor (Forget r) where
  dimap f _ (Forget z) = Forget (z <<< f)
  
instance Strong (Forget r) where
  first (Forget z) = Forget (z <<< fst)
  second (Forget z) = Forget (z <<< snd)
  
instance Monoid r => Choice (Forget r) where
  left (Forget z) = Forget (either z mempty)
  right (Forget z) = Forget (either mempty z)

type Fold r s t a b = Optic (Forget r) s t a b
type Getter s t a b = forall r. Fold r s t a b

view :: forall s t a b. Getter s t a b -> s -> a
view = unwrap <<< (#) (Forget identity)

iso :: forall s t a b. (s -> a) -> (b -> t) -> Iso s t a b
iso = dimap

lens :: forall s t a b. (s -> a) -> (s -> b -> t) -> Lens s t a b
lens get set = lens' \s -> get s /\ set s where
  lens' to pab = dimap to (\(b /\ f) -> f b) (first pab)
  
prism :: forall s t a b. (b -> t) -> (s -> Either t a) -> Prism s t a b
prism to fro pab = dimap fro (either identity identity) (right (rmap to pab)) where
  rmap = dimap identity

class Semiring a where
  add :: a -> a -> a
  zero :: a
  mul :: a -> a -> a
  one :: a

data Number :: Type

instance semiringNumber :: Semiring Number where
  add = (+)
  zero = 0
  mul = (*)
  one = 1

-- Haskell's Num:
class (Semiring a) <= Ring a where
  sub :: a -> a -> a

class (Ring a) <= CommutativeRing a

class (Ring a) <= DivisionRing a where
  recip :: a -> a -> a

-- Haskell's Integral:
class (CommutativeRing a) <= EuclideanRing a where
  degree :: a -> Int
  div :: a -> a -> a
  mod :: a -> a -> a

--Haskell's Fractional:
class (EuclideanRing a, DivisionRing a) <= Field a

type NaturalTransformation f g = forall a. f a -> g a
infixr 4 type NaturalTransformation as ~>

-- unicode CodePoint
"\x2713" :: String -- checkmark

> import Data.Int
> toStringAs hexadecimal 175
"af"

data NonEmpty a = NonEmpty a (Array a)

instance eqNonEmpty :: (Eq a, Eq (Array a)) => Eq (NonEmpty a) where
  eq (NonEmpty x xs) (NonEmpty y ys) = x == y && xs == ys

> import Data.Array(head) as Array
> Array.head xs
(Just 1)

> import Data.Array.Partial(head) as Partial
> unsafePartial Partial.head xs
1

nonEmpty :: String -> Either String Unit
nonEmpty "" = Left "Field cannot be empty"
nonEmpty _  = Right unit

newtype Person = Person
  { firstName   :: String
  , lastName    :: String
  }

person :: String -> String -> Person
person firstName lastName =
  Person { firstName, lastName}

validatePerson :: Person -> Either String Person
validatePerson (Person o) =
  person <$> (nonEmpty o.firstName *> pure o.firstName)
         <*> (nonEmpty o.lastName  *> pure o.lastName)

sort $ nub $ map sum $ foldM (\xs x -> [x:xs,xs]) [] ([1,2,5,10])
 
> import Data.List(filterM,fromFoldable,toUnfoldable)
> subsets = filterM (const [true, false])
> (map toUnfoldable $ subsets $ fromFoldable [4,2,6,3]) :: Array (Array Int)

import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class
sumArray = traverse_ \n -> modify \sum -> sum + n
runState (do
  sumArray [1, 2, 3]
  sumArray [4, 5]
  sumArray [6]) 0

vowelsRegex :: Regex
vowelsRegex =
  unsafePartial
    case regex "[aeiou]" (RegexFlags regexFlags) of
      Right r -> r

> :paste
… merch3 = ado
…   x <- "teeshirt" : "sweater" : Nil
…   y <- "large" : "medium" : "small" : Nil
…   z <- "black" : "white" : Nil 
…   in (x <> "-" <> y <> "-" <> z)
… 

> :paste
… merch4 = do
…   x <- "teeshirt" : "sweater" : Nil
…   y <- "large" : "medium" : "small" : Nil
…   z <- "black" : "white" : Nil 
…   pure (x <> "-" <> y <> "-" <> z)
… 

> merch3 == merch4
true

 mkdir show-instance
$ cd show-instance
$ spago init
$ spago install generics-rep
$ spago repl
> import Data.Generic.Rep
> import Data.Show
> import Data.Generic.Rep.Show
> data Action = Change String | Focus
> derive instance genAction :: Generic Action _
> instance showAction :: Show Action where show a = genericShow a
> Change "hi"
(Change "hi")

newtype State s a = State { runState :: s -> {fst :: a, snd :: s} }  

instance functorState :: Functor (State s) where
  map f (State st) = State {runState: \s -> 
                        (\{fst: b, snd} -> {fst: f b, snd}) (st.runState s)}

instance applicativeState :: Applicative (State s) where
  pure x = State {runState: \s -> {fst: x, snd: s} } 

instance applyState :: Apply (State s)  where
  apply = ap

instance bindState :: Bind (State s) where  
    bind (State h) f = State {runState: \s -> 
                                 let {fst: a, snd: newState} = h.runState s  
                                     State g = f a  
                                  in g.runState newState
                                 }  
instance monadState :: Monad (State s)

put :: forall a. a -> State (Array a) Unit  
put a = State {runState: \xs -> {fst: unit, snd: snoc xs a}}

getArray (State {runState}) = (runState []).snd

import Data.Array(snoc)
import Control.Monad.State(State(..), runState)
import Data.Tuple(fst)
import Control.Monad.State.Class(class MonadState, get, modify)

put :: forall a st. Functor st => MonadState (Array a) st => a -> st Unit
put x = void $ modify (flip snoc x)

fromSeq :: forall a. State (Array a) (Array a) -> Array a
fromSeq seq = fst $ runState seq []

seqArray :: State (Array Int) (Array Int)
seqArray = do
  put 2
  put 3
  put 4
  get

class Interp a where
  interp :: String -> a

instance interpString :: Interp String where
  interp a = a
else instance interpFunction :: Interp a => Interp (String -> a) where
  interp a b = interp (a <> b)
else instance interpShow :: (Show b, Interp a) => Interp (b -> a) where
  interp a b = interp (a <> show b)

i = interp

test = i "foo" 42 "bar" true "baz"

import Data.Variant (SProxy(..), Variant, inj)

type TestRow = (a :: Int, b :: Boolean)

type TestRec = Record TestRow

rab = {a: 1, b: true} :: TestRec

type TestVar = Variant TestRow

va = inj (SProxy :: SProxy "a") 6     :: TestVar
vb = inj (SProxy :: SProxy "b") false :: TestVar

-- customized do:
import Prelude hiding (bind, discard)

bind :: forall a r q. ((a -> r) -> q) -> (a -> r) -> q
bind f a = f a

discard = bind

