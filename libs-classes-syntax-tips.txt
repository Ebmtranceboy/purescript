Data.Functor              bower install purescript-prelude --save
Control.Applicative
Control.Apply
Control.Monad
Data.Eq
Data.Ordering
Data.Symbol
Prim.RowList
(...)

Control.Monad.Aff         bower install purescript-aff --save
Affjax                    bower install purescript-affjax --save
Data.Argonaut             bower install purescript-argonaut --save
Data.Array                bower install purescript-arrays --save
FRP.Behavior              bower install purescript-behaviors --save
Data.BigInt               bower install purescript-bigints --save
Graphics.Canvas           bower install purescript-canvas --save
Control.MonadZero         bower install purescript-control --save
Control.Alt               bower install purescript-control --save
Control.Plus              bower install purescript-control --save
Debug.Trace               bower install purescript-debug --save
Graphics.Drawing          bower install purescript-drawing --save
Data.Either               bower install purescript-either --save
Data.Enum                 bower install purescript-enums --save
Data.Traversable          bower install purescript-foldable-traversable --save
Data.Foldable             bower install purescript-foldable-traversable --save
Data.Foreign              bower install purescript-foreign --save
Data.Function.Uncurried   bower install purescript-functions --save
Data.Int                  bower install purescript-integers --save
Data.List                 bower install purescript-lists --save
Math                      bower install purescript-math --save
Data.Maybe                bower install purescript-maybe --save
Data.Monoid               bower install purescript-monoid --save
Data.Newtype              bower install purescript-newtype --save
Data.Map                  bower install purescript-ordered-collections --save
Partial.Unsafe            bower install purescript-partial --save
Effect.Random             bower install purescript-random --save
Data.Ratio                bower install purescript-rationals --save
Record                    bower install purescript-record --save
Run                       bower install purescript-run --save
Data.Set                  bower install purescript-sets --save
Control.Monad.ST          bower install purescript-st --save
Data.String               bower install purescript-strings --save
Data.Char                 bower install purescript-strings --save
Thermite                  bower install purescript-thermite --save
Control.Monad.State       bower install purescript-transformers --save
Data.Tuple                bower install purescript-tuples --save
Type.Prelude              bower install purescript-typelevel-prelude --save
Turbine                   bower install purescript-turbine --save
Data.Validation.Semigroup bower install purescript-validation --save
Web.HTML                  bower install purescript-web-html --save
Audio.WebAudio.Oscillator bower install purescript-webaudio --save

import Control.Alt(alt)
import Control.Monad.ST(newSTRef)
import Control.MonadZero(guard)
import Data.Array(foldM, catMaybes,sort)
import Data.Array.Partial(head)
import Data.Char(toCharCode)
import Data.Enum(fromEnum)
import Data.Foldable(sum, product, foldM, maximum)
import Data.Function.Uncurried(Fn's, mkFn's, runFn's)
import Data.Int(floor, fromStringAs, toStringAs, binary, octal, hexadecimal, decimal, base36, radix, toNumber)
import Data.List(fromFoldable, filterM, toUnfoldable)
import Data.Maybe(fromJust, maybe)
import Data.String(toCodePointArray, singleton, fromCodePointArray, codePointFromChar,stripPrefix,Pattern)
import Data.String.CodeUnits(toCharArray, singleton)
import Partial.Unsafe (unsafePartial)
import Data.Tuple(uncurry)
import Data.Ord(min,max,abs)

class Eq a where
  eq :: a -> a -> Boolean
  
data Ordering = LT | EQ | GT

class Eq a <= Ord a where
  compare :: a -> a -> Ordering

class Semigroupoid a where
  compose :: forall b c d. a c d -> a b c -> a b d

class Semigroupoid a <= Category a where
  id :: forall t. a t t

class Semigroup a where
  append :: a -> a -> a
  
class (Semigroup m) <= Monoid m where
  mempty :: m

class Foldable f where
  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m

class Functor f where
  map :: forall a b. (a -> b) -> f a -> f b

infixl 4 map as <$>

instance covariantArrow :: Covariant (forall a. a -> x) where
  fmap :: (x -> y) -> (a -> x) -> (a -> y) -- result is still a function a -> ...
  fmap = (<<<)

instance contravariantArrow :: Contravariant (forall b. x -> b) where
  cmap :: (x -> b) (b -> y) -> (x -> y) -- result is still a function ... -> b
  cmap = flip (<<<)
  
It appears that a functor (resp. cofunctor) instance can only be defined 
for functions where variables x all are in positive (resp. negative) positions:

p
n -> p
n -> (n -> p)
(p -> n) -> p
n -> (n -> (n -> p))
n -> ((p -> n) -> p)
((n -> p) -> n) -> p 
(p -> (p -> n)) -> p 
(p -> n) -> (n -> p)

for example,
instance covariantArrow2 :: Covariant (forall n. (x -> n) -> x) where
  fmap :: (x -> y) -> ((x -> n) -> x) -> (x -> n) -> y

class Functor f <= Apply f where
  apply :: forall a b. f (a -> b) -> f a -> f b 

infixl 4 apply as <*>

class Apply f <= Applicative f where
  pure :: forall a. a -> f a

class (Functor t, Foldable t) <= Traversable t where
  traverse :: forall a b f. Applicative f => (a -> f b) -> t a -> f (t b)
  sequence :: forall a f. Applicative f => t (f a) -> f (t a)

-- sequence = traverse identity
-- traverse f = sequence <<< (map f)
-- traverse_ :: forall a b t f. Applicative f => Foldable t => (a -> f b) -> t a -> f Unit

class Apply m <= Bind m where
  bind :: forall a b. m a -> (a -> m b) -> m b

class (Applicative m, Bind m) <= Monad m

data Tuple a b = Tuple a b

class Monad m <= MonadState s m | m -> s where
  state :: forall a. (s -> (Tuple a s)) -> m a

class Functor env <= Extend env where -- that is : map f = extend (f <<< duplicate)
  duplicate : forall a. env a -> env (env a) 
  -- that is : duplicate = extend identity
  extend :: forall a b. (env a -> b) -> env a -> env b
  -- that is : extend f = map f <<< duplicate

class Comonad env where
  extract :: forall a. env a -> a

class Comonad (env e) <= Environment env e a where
  ask :: env e a -> e
  asks :: forall e'. (e -> e') -> env e a -> e'
  local :: forall e'. (e -> e') -> env e a -> env e' a

class Semiring a where
  add :: a -> a -> a
  zero :: a
  mul :: a -> a -> a
  one :: a

data Number :: Type

instance semiringNumber :: Semiring Number where
  add = (+)
  zero = 0
  mul = (*)
  one = 1

-- Haskell's Num:
class (Semiring a) <= Ring a where
  sub :: a -> a -> a

class (Ring a) <= CommutativeRing a

class (Ring a) <= DivisionRing a where
  recip :: a -> a -> a

-- Haskell's Integral:
class (CommutativeRing a) <= EuclideanRing a where
  degree :: a -> Int
  div :: a -> a -> a
  mod :: a -> a -> a

--Haskell's Fractional:
class (EuclideanRing a, DivisionRing a) <= Field a

data NonEmpty a = NonEmpty a (Array a)

instance eqNonEmpty :: (Eq a, Eq (Array a)) => Eq (NonEmpty a) where
  eq (NonEmpty x xs) (NonEmpty y ys) = x == y && xs == ys

> import Data.Array(head) as Array
> Array.head xs
(Just 1)

> import Data.Array.Partial(head) as Partial
> unsafePartial Partial.head xs
1

nonEmpty :: String -> Either String Unit
nonEmpty "" = Left "Field cannot be empty"
nonEmpty _  = Right unit

newtype Person = Person
  { firstName   :: String
  , lastName    :: String
  }

person :: String -> String -> Person
person firstName lastName =
  Person { firstName, lastName}

validatePerson :: Person -> Either String Person
validatePerson (Person o) =
  person <$> (nonEmpty o.firstName *> pure o.firstName)
         <*> (nonEmpty o.lastName  *> pure o.lastName)

sort $ nub $ map sum $ foldM (\xs x -> [x:xs,xs]) [] ([1,2,5,10])
 
> import Data.List(filterM,fromFoldable,toUnfoldable)
> subsets = filterM (const [true, false])
> (map toUnfoldable $ subsets $ fromFoldable [4,2,6,3]) :: Array (Array Int)

import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class
sumArray = traverse_ \n -> modify \sum -> sum + n
runState (do
  sumArray [1, 2, 3]
  sumArray [4, 5]
  sumArray [6]) 0

vowelsRegex :: Regex
vowelsRegex =
  unsafePartial
    case regex "[aeiou]" (RegexFlags regexFlags) of
      Right r -> r

> :paste
… merch3 = ado
…   x <- "teeshirt" : "sweater" : Nil
…   y <- "large" : "medium" : "small" : Nil
…   z <- "black" : "white" : Nil 
…   in (x <> "-" <> y <> "-" <> z)
… 

> :paste
… merch4 = do
…   x <- "teeshirt" : "sweater" : Nil
…   y <- "large" : "medium" : "small" : Nil
…   z <- "black" : "white" : Nil 
…   pure (x <> "-" <> y <> "-" <> z)
… 

> merch3 == merch4
true

 mkdir show-instance
$ cd show-instance
$ spago init
$ spago install generics-rep
$ spago repl
> import Data.Generic.Rep
> import Data.Show
> import Data.Generic.Rep.Show
> data Action = Change String | Focus
> derive instance genAction :: Generic Action _
> instance showAction :: Show Action where show a = genericShow a
> Change "hi"
(Change "hi")