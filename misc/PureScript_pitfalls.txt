PURESCRIPT TIPS
---------------

* When unexpected type error:
1) Check that it doesn't happens for a let-defined function used several times, with different argument types (e.g. mapmap)
2) If it is, the solution is to define it globally, providing a general type definition.

* Don't get confused with lift versions:

import Control.Apply(lift2)
import Data.Traversable (traverse)

(<$>) :: forall a b f. Functor f => (a -> b) -> f a -> f b
(<*>) :: forall a b f. Apply f => f (a -> b) -> f a -> f b
zipWith :: forall a b c. (a -> b -> c) -> Array a -> Array b -> Array c

e.g. add <$> [1,20] <*> [300,4000] == [301,4001,320,4020]
     lift2 add [1,20] [300,4000] == [301,4001,320,4020]

e.g. zipWith add [1,20] [300,4000] == [301,4020]
     zipWith (zipWith add) [[1,20],[300,4000]] [[42,314],[666]]
     == [[43,334],[966]]
     zipWith add <$> [[1,20],[300,4000]] <*> [[42,314],[666]] 
     == [[43,334],[667],[342,4314],[966]]

gridxy :: forall a b c f. Functor f => (a -> b -> c) -> f a -> f b -> f (f c)
gridxy f xs ys = (\y -> (\x -> f x y) <$> xs) <$> ys

gridyx :: forall a b c f. Functor f => (a -> b -> c) -> f a -> f b -> f (f c)
gridyx f xs ys = (\x -> (\y -> f x y) <$> ys) <$> xs

e.g. gridxy add [1,20] [300,4000] == [[301,320],[4001,4020]]
     gridyx add [1,20] [300,4000] == [[301,4001],[320,4020]]
     
e.g. traverse add [1,20] <$> [300,4000] == [[301,320],[4001,4020]]

mapmap :: forall a b f. Functor f => (a -> b) -> f (f a) -> f (f b)
mapmap = (<$>) <<< (<$>)

e.g. (_ + 1) `mapmap` [[1,20],[300,4000]] == [[2,21],[301,4001]]

* ST

Q: why
ST.run do
  stObj <- STObj.new
  stObj' <- foldM groupFn stObj somePureValue
  unsafeFreeze stObj'

A: groupFn probably doesn’t have a signature. Anything that’s in a binding and uses ST needs a signature.

* "mutable" arrays

import Control.Monad.ST (ST, run, for)
import Data.Array.ST (STArray, peek, poke, withArray)

arr :: Array Int
arr = run (withArray build (replicate n zero))

build :: forall h. STArray h Int -> ST h Unit
build a =
  for 1 (n-1) \ i -> do
    ma1 <- peek (i-1) a
    let a1 = unsafePartial $ fromJust ma1
    poke i (a1+1) a


* Q : what is the “standard” way to shuffle an array in purescript?
just use FFI?
it seems hard to do with ST as you need Effect as well

A : You can lift ST into Effect with liftST

* string-splitting:
import Data.Int (fromString)
import Data.String (Pattern(..), split)
fromString <$> split (Pattern "") "11068" == [(Just 1),(Just 1),(Just 0),(Just 6),(Just 8)]
traverse fromString $ split (Pattern "") "11068" == (Just [1,1,0,6,8])


* json
You should be able to safely unsafeCoerce a Foreign that comes out of simple-json to a Json or the other way around. Json is generally used for things that might result from a JS JSON.parse , whereas Foreign can be any sort of javascript value or object, so it might not be safe to unsafeCoerce a Foreign representing a closure, or undefined or something, to a Json.
The thing that made simple-json good is now also in argonaut,
argonaut-codecs ( bundled with the argonaut meta-package) if you just need to serialize or deserialize (separate, explicit encoders and decoders), codec-argonaut if you need to do both (bidirectional).

* 
class Bifunctor f where
  bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
  
  
class Profunctor f where
  bimap :: (a -> b) -> (c -> d) -> f b c -> f a d
  
  
Profunctor is similar to Bifunctor except where Bifunctor allows you to map (covariant functor) on two types, Profunctor has one contravariant and one covariant parameter
